#!/usr/bin/perl

use threads;
use Tabix;
use strict;
use warnings;
use Math::CDF;
use Set::IntervalTree;
use Set::IntSpan::Fast;
use Getopt::Long;
no autovivification;

my $usage = "

NO-CALL-FILTER --bed my.bedfile --build my.build.txt -c coverage.gz -g gvf  -l low.coverage.cut -q low.quality.cut --threads 5

";

my ($help);
my $bgi_depth;
my $gvf;
my $build;
my $quality = 20;
my $ldepth = 5;
my $hdepth;
my $coverage;
my $bed;
my $n_threads = 4;
my $opt_success = GetOptions('help'         => \$help,
                             "low_depth=s"  => \$ldepth,
			     "high_depth=s" => \$hdepth,
			     "coverage=s"   => \$coverage,
			     "gvf=s"        => \$gvf, 
			     "quality=s"    => \$quality,
                             "build=s"      => \$build,
			     "bed=s"        => \$bed,
			     "threads=s"    => \$n_threads,
    );

die $usage if $help || ! $opt_success;
die $usage unless defined $gvf && defined $ldepth && defined $quality && defined $build && defined $coverage && $bed; 

my %BUILD;
my %BED;

#-----------------------------------------------------------------------------
#----------------------------------- MAIN ------------------------------------
#-----------------------------------------------------------------------------

Parse_Build($build);
Parse_BED($bed);
my $gvf_t    = Tabix->new(-data=>$gvf);
my %features = map {$_ => 1}  $gvf_t->getnames();
Run_Threads(\%features);

#-----------------------------------------------------------------------------
#-------------------------------- SUBROUTINES --------------------------------
#-----------------------------------------------------------------------------
sub Handel_Run{
    my $feature             = shift;
    my $gvf_t               = Tabix->new(-data=>$gvf);
    my $cov_t               = Tabix->new(-data=>$coverage);
    my $gvf_iter            = $gvf_t->query($feature);
    my $cov_iter            = $cov_t->query($feature);
    my $depth_count  = Count_Depth($cov_t, $cov_iter);
    $hdepth                 = Estimate_High($depth_count, $feature) if ! defined $hdepth;
    $cov_iter               = $cov_t->query($feature);
    my $ranges              = Range_Depth($cov_t, $cov_iter, $feature);
    my $gvf_ranged          = Process_GVF($gvf_t, $gvf_iter, $ranges, $feature);
#    my $gvf_depth           = Del_Range($ranges, $gvf_range, $feature); 
#    my ($gvf_depth, $tree)  = Del_Range($ranges, $gvf_range, $feature); 
    Print_Gvf($feature, $gvf_ranged);
}
#-----------------------------------------------------------------------------
sub Run_Threads{
    my $features = shift;
    my @features = keys %{$features};
    
    while(@features){
	my @child;
	my @temp_features;
	if (scalar @features % $n_threads){
	    for(my $i = 0; $i <= $n_threads; $i++){
		my $feature = shift @features;
		push @temp_features, $feature;
	    }
	}
	else{
	    for(my $i = 0; $i <= scalar @features; $i++){
		my $feature = shift @features;
		push @temp_features, $feature;
	    }
	}
	my $child = Fork_Threads(\@temp_features);
	foreach my $c (@{$child}){
	    my $tmp = waitpid($c, 0);
	}
    }
}

#-----------------------------------------------------------------------------
sub Fork_Threads{    
    my $f = shift;
    my @childs;
    foreach my $feature (@{$f}){ 
	next if ! defined $feature;
	my $pid = fork();
        if ($pid) {
	    # parent
	    #print "pid is $pid, parent $$\n";
	    push(@childs, $pid);
        } elsif ($pid == 0) {
	    # child
	    Handel_Run($feature);
	    exit 0;
        } else {
	    die "couldnt fork: $!\n";
        }
    }	
    return \@childs;
}

#-----------------------------------------------------------------------------

sub Parse_BED{
    my $file = shift;
    open(FH, '<', $file) || die "cannot open BED $file\n";
    while (my $l = <FH>) {
	chomp $l;
	
	# Model-centric match.  I should consider changing this. 
	
	next if $l !~ /^chr*/;
	my @l = split /\t/,  $l;
	$BED{$l[0]} += ($l[2] - $l[1]) + 1;
    }
    close FH;
}
#-----------------------------------------------------------------------------
    
# In order to add a gap from the beginning of the genome to the first exome
# regions you need to parse the build so that you know from 0 -> start and  
# 999 -> end of each seqid.  data is $BUILD{seqid} = length;

sub Parse_Build{
    my $file = shift;
    open(FH, '<', $file) || die "cannot open build $file\n";
    while(my $l = <FH>){
	
	# skipping lines that begin with whitespace or comments

	next if $l =~ /^\s+|#/;
	my @l = split /\s+/, $l;
	die "$file is not in correct format\n" if scalar @l != 3;
	$BUILD{$l[0]} = $l[2];
    }
    close FH;
}
#-----------------------------------------------------------------------------                        

# I decided to bin the counts for each depth in a hash incase I wanted to
# change the way I used the depth count information. $depth_count{depth=10}++
# Returned is the depth count hash.

sub Count_Depth{ 
    my ($t,  $iter) = @_;
    my %depth_count;
    print STDERR "Current Stage: Counting depth\n";
    while(my $l = $t->read($iter)){
	my @l = split /\t/, $l;
	$depth_count{$l[2]}++; 
    }
    return \%depth_count;
}  
#-----------------------------------------------------------------------------

# Loop through %depth_count and sum the depths across all counts.
# lambda (mean) is the $total_depth / feature length.  whole genome needs a
# a bed file which will  be the same as build. I am looking at all position in
# the bed this means the lambda will be lower than if i only look at positions
# that have coverage. The high depth cutoff is returned.

sub Estimate_High{
    my ($depth_count, $feature) = @_;
    print STDERR "Current Stage: Estimating upper depth cutoff\n";
    my $total_depth;
    while(my ($depth, $count) = each %{$depth_count}){
	$total_depth  += $depth * ($count + 1);
    }
    my $lambda  = $total_depth > 0 ? $total_depth / $BED{$feature} : 0;
    print STDERR "The lamda for $feature is $lambda\n";
    my $h_cut   = $lambda == 0 || ! defined $lambda ? 0 : Math::CDF::qpois(0.98, $lambda);
    print STDERR "low coverage dected! check $feature. high coverage cutoff \= $h_cut\n" if $h_cut < 1;
    return $h_cut;
}      
#-----------------------------------------------------------------------------

# I am handeling all gap infromation and ranges in Set::IntSpan::Fast.  
# Critical to have the compiled version of Set::IntSpan::Fast
# Returns the Set::IntSpan::Fast::Object


sub Range_Depth{



    my ($t, $iter, $feature) = @_;
   
    # Initializing the set
     
    my $set = Set::IntSpan::Fast->new();   

    # Last seen position

    my $lpos = 0;

    print STDERR "Current Stage: Ranging gap\n";
    while(my $l = $t->read($iter)){
	my @l = split /\t/, $l;
	
	# Adds gaps for regions where there is a break 
	# in ther coordinates

	if($l[1] != $lpos + 1){
	    my $start = $lpos+1;
	    my $end = $l[1]-1;
	    $set->add_range($start, $end);
	}
	
	# Reassigning last position

	$lpos = $l[1];

	# If a position fails on depth high or low pass to 
	# gap set

	$set->add($l[1]) if $l[2] < $ldepth || $l[2] > $hdepth;
    }

    # Check at end to see if we are to the end of the length of the seqid
    # if not pass the range as a gap to the set

    if($lpos < $BUILD{$feature}){
	my $start = $lpos + 1;
	my $end = $BUILD{$feature};
	$set->add_range($start, $end); 
    }

    return $set;
}	
#-----------------------------------------------------------------------------
sub Process_GVF{

    # Create the GVF hash, add gaps, and parse the current feature.
    # Iterate the Set object to add gaps the the GVF hash.
  
    my ($t, $iter, $ranges, $feature) = @_;
    my %gvf;

    #Loop the GVF;


    while(my $l = $t->read($iter)){
	my ($seqid, $source, $type, $start, $end, $score, $strand, $phase, 
	    $attributes) = split /\t/, $l;
	
	# Contains_any makes sure the SNV/INDEL ect doesn't overlap a gap.
	
	if(! defined $ranges->contains_any($start .. $end)){
	    $gvf{$start}{$end} = "$type\t$source\t$score\t$strand\t$phase\t$attributes" 
	    }
	
	# If contains any is true we want to process genotypes contained in 
	# attriubte line.
	
	else{
	    
	    # Remove the gap position to allow for the mutation
	    
	    $ranges->remove_range($start, $end);
	
	    #load attributes and check for key value pairs;
	    
	    my %attributes;	    
	    foreach my $key_val_pair (split /;/, $attributes){
		my ($key, $value) = split /=/, $key_val_pair;
		die "Attribute line is not conform to spefication:\n$l\n" if ! defined $key || ! defined $value;
		$attributes{$key} = $value;
	    }
	    my $var = $attributes{Variant_seq}; 
	    my $ref = $attributes{Reference_seq};
	
	    # if the variant line is longer than three we know its a het or some strange polymorphic
	    # site within an indvidual.  We are assuming these sites shouldn't be touched?  Chad's thoughts. 
	    
	    if(length $var  >= 3 ){
		$gvf{$start}{$end} = "$type\t$source\t$score\t$strand\t$phase\t$attributes";
	    }
	    else{
		
		# we know we are homozygous non ref
		
		my @genotype = grep {!/$ref/} split /,/, $var;
                push @genotype, '^';
		if(scalar @genotype > 2){
		    @genotype = ('^','^');
		}
                $attributes{Variant_seq} = join ",", @genotype;

		#maintaining some order to my hash
		
		my @attrib;
		my @order = ("ID","Variant_seq", "Reference_seq", "Total_reads", "Zygosity");
		foreach my $o (@order){
		    push @attrib, join "=", ($o, $attributes{$o});
		    delete $attributes{$o};
		    
		}
		
		#loading the rest of the key value
		
		while(my($k, $v) = each %attributes){
		    push @attrib, join "=", ($k,  $v);
		}

		#joining key values

		$attributes = join ";", @attrib;
		
		#loading mutation into gvf.....
		
		$gvf{$start}{$end} = "$type\t$source\t$score\t$strand\t$phase\t$attributes;";
	    }
	}   
    }
    
    
    print STDERR "Current Stage: adding gaps\n";
    my $it = $ranges->iterate_runs();
    while (my ( $from, $to ) = $it->()) {
	$gvf{$from}{$to} = "gap\tno_call\t.\t.\t.\tID=$feature:$from:$to;";
    }
  
    return(\%gvf); 
}
#-----------------------------------------------------------------------------

# This code isn't being used

sub Del_Range{  
    my $ranges  = shift;
    my $gvf     = shift;
    my $feature = shift;

   # my $tree = Set::IntervalTree->new;

   
   # setinterval implementation
    my $iter = $ranges->iterate_runs();
    while (my ( $from, $to ) = $iter->()) {
    	$gvf->{$from}{$to} = "gap\tno_call\t.\t.\t.\tID=$feature:$from:$to;";        
    }
 
    # my @ranges = split /,/, $ranges;
    # for my $range (@ranges){
    # my @ab_range = $range =~ /-/ ? split /-/, $range : ($range, $range);
#	$tree->insert("$feature:$ab_range[0]:$ab_range[1]", $ab_range[0], $ab_range[1]);
#	$gvf->{$ab_range[0]}{$ab_range[1]} = "gap\tno_call\t.\t.\t.\tID=$feature:$ab_range[0]:$ab_range[1];";    
#    }
    #return ($gvf, $tree);
    return $gvf;
}
#-----------------------------------------------------------------------------
sub Print_Gvf{

    my $feature = shift;
    my $gvf     = shift;
   # my $tree    = shift;
   # my $set     = shift;
 
  OUTER: while(my($s, $e_hash) = each %{$gvf}){
    INNER: while(my($e, $d) = each %{$gvf->{$s}}){
	my ($type, $source, $score, $strand, $phase, $attributes) = split /\t/, $d;
	if($type ne 'gap'){
	    if($score < $quality){
		$attributes =~ s/Zygosity=.*?;/Zygosity=homozygous;/;
		$attributes =~ s/Variant_seq=.*?;/Variant_seq=^;/;
	    }
	    print "$feature\t$source\t$type\t$s\t$e\t$score\t$strand\t$phase\t$attributes\n"   
	}
	else{
	    print "$feature\t$source\t$type\t$s\t$e\t$score\t$strand\t$phase\t$attributes\n"   
	}
    }
  }
}
#-----------------------------------------------------------------------------



